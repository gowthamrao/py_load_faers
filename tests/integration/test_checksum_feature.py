# -*- coding: utf-8 -*-
"""
This integration test specifically verifies the end-to-end persistence
of the source_checksum metadata field.
"""
import zipfile
from pathlib import Path

import pytest
from psycopg.rows import dict_row
from pytest_mock import MockerFixture

from py_load_faers.config import AppSettings, DatabaseSettings, DownloaderSettings
from py_load_faers.engine import FaersLoaderEngine
from py_load_faers.postgres.loader import PostgresLoader

# Mark all tests in this file as integration tests
pytestmark = pytest.mark.integration


@pytest.fixture
def app_settings(tmp_path: Path, db_settings: DatabaseSettings) -> AppSettings:
    """Provides application settings for the test."""
    return AppSettings(
        db=db_settings,
        downloader=DownloaderSettings(download_dir=str(tmp_path), retries=3, timeout=60),
    )


@pytest.fixture
def mock_ascii_zip(tmp_path: Path) -> Path:
    """Creates a simple mock FAERS ASCII zip file."""
    zip_path = tmp_path / "faers_ascii_2025q1.zip"
    with zipfile.ZipFile(zip_path, "w") as zf:
        zf.writestr("DEMO25Q1.txt", "primaryid$caseid\n1001$1")
    return zip_path


def test_checksum_is_persisted(
    app_settings: AppSettings,
    db_settings: DatabaseSettings,
    mock_ascii_zip: Path,
    mocker: MockerFixture,
    clean_db,
) -> None:
    """
    Tests that the checksum generated by the downloader is correctly
    persisted in the _faers_load_history table by the engine.
    """
    # 1. Setup
    known_checksum = "a" * 64  # A dummy but valid SHA-256 hex string
    quarter = "2025q1"

    # Mock the downloader to return our mock file and known checksum
    mocker.patch(
        "py_load_faers.engine.download_quarter",
        return_value=(mock_ascii_zip, known_checksum),
    )

    # 2. Run the engine (the database is initialized by the `clean_db` fixture)
    db_loader = PostgresLoader(db_settings)
    db_loader.connect()
    assert db_loader.conn is not None

    engine = FaersLoaderEngine(app_settings, db_loader)
    engine.run_load(quarter=quarter)  # Run for a single quarter

    # 3. Verify the checksum in the database
    # Create a new connection to ensure we're reading committed data
    final_checker = PostgresLoader(db_settings)
    try:
        final_checker.connect()
        assert final_checker.conn is not None
        with final_checker.conn.cursor(row_factory=dict_row) as cur:
            cur.execute(
                "SELECT source_checksum FROM _faers_load_history WHERE quarter = %s",
                (quarter,),
            )
            result = cur.fetchone()
            assert result is not None, "Load history record was not created"
            assert result["source_checksum"] == known_checksum
    finally:
        if final_checker.conn:
            final_checker.conn.close()
